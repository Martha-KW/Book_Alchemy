from data_models import db, Author, Book
from datetime import datetime
from flask import Flask, render_template, request, redirect, url_for, flash
from sqlalchemy import or_, func
import os



# Create an instance of the Flask application
app = Flask(__name__)
#  Secret key for flash message
app.secret_key = 'Frodo'


basedir = os.path.abspath(os.path.dirname(__file__))
app.config['SQLALCHEMY_DATABASE_URI'] = (
        'sqlite:///' + os.path.join(basedir, 'data', 'library.sqlite')
)

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db.init_app(app)
print("SQLite-Path:", os.path.join(basedir, 'data', 'library.sqlite'))

# route for the homepage
@app.route('/')
def home():
    """This Route creates the homepage that contains cards with the books,
    search functionality and links to the add author and the add book page.
    """
    sort_by = request.args.get('sort_by')
    search_term = request.args.get('search', '').strip()

    # Joins Book  and Author tables to be able to search for authors names
    query = Book.query.join(Author)

    # after inserting a search term in the field:
    if search_term:
        search_pattern = f"%{search_term.lower()}%"
        query = query.filter(
            or_(
                func.lower(Book.title).like(search_pattern),
                func.lower(Author.name).like(search_pattern),
                func.cast(Book.publication_year, db.String).like(search_pattern),
                Book.isbn.like(search_term)
            )
        )

    # sort the results
    if sort_by == 'title':
        query = query.order_by(Book.title)
    elif sort_by == 'author':
        query = query.order_by(Author.name)
    elif sort_by == 'publication_year':
        query = query.order_by(Book.publication_year)

    books = query.all()
    no_results = search_term and not books  # informs user that no matches found

    return render_template('home.html', books=books, no_results=no_results)




@app.route('/add_author', methods=['GET', 'POST'])
def add_author():
    """ This route generates a subpage where the user can add a new author to the author
    table. The id is autogenerated, the user has to input the authors name, day of birth and
    if the author is already dead the authors death date.
    """
    message = ""
    if request.method == 'POST':
        name = request.form['name']
        birth_date_str = request.form.get('birth_date')
        date_of_death_str = request.form.get('date_of_death')

        # convert the date strings to  datetime.date
        birth_date = (
            datetime.strptime(birth_date_str, '%Y-%m-%d').date()
            if birth_date_str else None
        )

        date_of_death = (
            datetime.strptime(date_of_death_str, '%Y-%m-%d').date()
            if (date_of_death_str) else None
        )

        new_author = Author(
            name=name,
            birth_date=birth_date,
            date_of_death=date_of_death
        )
        try:
            db.session.add(new_author)
            db.session.commit()
            message = f"Author '{name}' successfully added to database!"
        except Exception as e:
            db.session.rollback()
            message = f"Error adding author: {str(e)}"

    return render_template('add_author.html', message=message)


@app.route('/add_book', methods=['GET', 'POST'])
def add_book():
    """This route create the underpage where the user can add books to the book table. The
    authors id is autogenerated, the user adds the isbn, the book title. the publication
    year manually and via selecting the authors name from a drop down menu, the authors id
    in the table is added automatically.
    """
    message = ""
    authors = Author.query.all()

    if request.method == 'POST':
        title = request.form.get('title')
        isbn = request.form.get('isbn')
        publication_year = request.form.get('publication_year')
        author_id = request.form.get('author_id')

        try:
            new_book = Book(
                title=title,
                isbn=isbn,
                publication_year=int(publication_year) if publication_year else None,
                author_id=int(author_id)
            )
            db.session.add(new_book)
            db.session.commit()
            message = f"Book '{title}' successfully added!"
        except Exception as e:
            db.session.rollback()
            message = f"Error adding book: {e}"

    return render_template('add_book.html', authors=authors, message=message)


@app.route('/book/<int:book_id>/delete', methods=['POST'])
def delete_book(book_id):
    """ This enables the user to delete a single book while clicking on a button on the
    book card in the html interface. The button uses this route.
    """
    book = Book.query.get_or_404(book_id)
    author = Author.query.get(book.author_id)

    db.session.delete(book)
    db.session.commit()

    # check if author has other books
    other_books = Book.query.filter_by(author_id=author.id).count()
    if other_books == 0:
        db.session.delete(author)
        db.session.commit()
    #  flash message to confirm successful deletion
    flash(f'„{book.title}“ successfully deleted.', 'success')
    return redirect(url_for('home'))


@app.route('/author/<int:author_id>')
def author_detail(author_id):
    """
    This route creates the subpage that displays the birthdates and optional deathdates
    of the author.
    """
    author = Author.query.get_or_404(author_id)
    return render_template('author_detail.html', author=author)



# creates the tables, first time use only, reactivate if you want to start a new library
# with app.app_context():
#     db.create_all()

# helps with debugging if needed
print("working directory:", os.getcwd())

if __name__ == '__main__':
    app.run(debug=True)
